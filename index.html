<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>æ‰‹åŠ¿æ§åˆ¶åœ£è¯æ ‘ - Gesture Christmas Tree</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background: #000000;  /* çº¯é»‘èƒŒæ™¯ */
            overflow: hidden;
            color: #ffd700;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #status-panel {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
        }

        #status-panel h1 {
            font-size: 2.5em;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(212, 175, 55, 0.5);
            margin-bottom: 10px;
        }

        #gesture-status {
            font-size: 1.2em;
            color: #d4af37;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.6);
            padding: 10px 25px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 20px;
            display: inline-block;
        }

        #controls {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 1000;
            pointer-events: auto;
        }

        #controls button {
            padding: 15px 35px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            background: linear-gradient(135deg, #d4af37 0%, #ffd700 100%);
            color: #0a0e0a;
            border: 2px solid #ffd700;
            border-radius: 30px;
            box-shadow: 0 5px 20px rgba(212, 175, 55, 0.4);
            transition: all 0.3s;
            pointer-events: auto;
        }

        #controls button:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 30px rgba(212, 175, 55, 0.6);
            background: linear-gradient(135deg, #ffd700 0%, #ffe066 100%);
        }

        #controls button:active {
            transform: scale(0.98);
        }
    </style>
</head>
<body>

<div id="canvas-container"></div>

<div id="ui-overlay">
    <div id="status-panel">
        <h1>ğŸ„ åœ£è¯æ ‘</h1>
        <div id="gesture-status">ç‚¹å‡»æŒ‰é’®æ§åˆ¶åœ£è¯æ ‘</div>
    </div>

    <div id="controls">
        <button id="folded-btn">âœŠ èšåˆæˆæ ‘</button>
        <button id="scattered-btn">âœ¨ ç²’å­æ•£å¼€</button>
    </div>
</div>

<!-- Three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
// ==================== å…¨å±€å˜é‡ ====================
let scene, camera, renderer;
let particles = [];
let messageImage = null;  // ç¥ç¦å›¾ç‰‡
let currentState = 'scattered'; // 'folded', 'scattered'ï¼ˆåˆå§‹ä¸ºæ•£å¼€çŠ¶æ€ï¼‰
let mouse3D = new THREE.Vector3(999, 999, 999);  // é¼ æ ‡3Dä½ç½®
let star = null;  // é¡¶éƒ¨æ˜Ÿæ˜Ÿ

const CONFIG = {
    particleCount: 4000,      // å¢åŠ åˆ°4000ä¸ªç»†å°ç²’å­
    colors: {
        amber: 0xffbf00,      // ç¥ç€é‡‘
        auroraGreen: 0x00ff9d, // æå…‰ç»¿
        iceBlue: 0x66d9ff,    // å†°é›ªè“
        starGold: 0xffd700    // æ˜Ÿæ˜Ÿé‡‘
    },
    lerpSpeed: 0.08,
    cameraDistance: 28,
    mouseInfluenceRadius: 5,   // é¼ æ ‡å½±å“åŠå¾„
    mouseForce: 0.3           // é¼ æ ‡ä½œç”¨åŠ›
};

// ==================== åˆå§‹åŒ– ====================
function init() {
    if (typeof THREE === 'undefined') {
        document.getElementById('gesture-status').innerText = 'é”™è¯¯ï¼šæ— æ³•åŠ è½½ Three.js';
        return;
    }

    // åœºæ™¯
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a1628);  // æ·±å¤œç©ºè“
    scene.fog = new THREE.Fog(0x0a1628, 30, 60);  // é›¾æ•ˆå¢åŠ çºµæ·±

    // ç›¸æœº
    camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );
    camera.position.set(0, 5, CONFIG.cameraDistance); // æé«˜ç›¸æœºä½ç½®ï¼Œä¿¯è§†è§’åº¦
    camera.lookAt(0, 4, 0);  // çœ‹å‘æ ‘çš„ä¸­ä¸Šéƒ¨

    // æ¸²æŸ“å™¨
    renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.5;  // æé«˜æ›å…‰ï¼Œå¢å¼ºå‘å…‰æ•ˆæœ
    renderer.shadowMap.enabled = false;   // å…³é—­é˜´å½±ï¼Œä¸éœ€è¦
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // å…‰ç…§ç³»ç»Ÿ
    setupLights();

    // äº‹ä»¶ç›‘å¬
    setupEventListeners();

    // åŠ è½½ç¥ç¦å›¾ç‰‡
    loadMessageImage();

    // åˆ›å»ºç²’å­ç³»ç»Ÿ
    createParticles();

    animate();
}

function setupLights() {
    // ç¯å¢ƒå…‰ï¼ˆç•¥å¼ºï¼Œç…§äº®ç»¿è‰²æ ‘èº«ï¼‰
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
    scene.add(ambientLight);

    // ä¸»å…‰æºï¼ˆæš–ç™½è‰²ï¼Œå¹³è¡¡çº¢ç»¿ï¼‰
    const mainLight = new THREE.PointLight(0xfff8f0, 2.0, 60);
    mainLight.position.set(0, 15, 15);
    scene.add(mainLight);

    // é¡¶éƒ¨èšå…‰ç¯ï¼ˆé‡‘è‰²ï¼Œç…§äº®æ˜Ÿæ˜Ÿï¼‰
    const topLight = new THREE.PointLight(0xffd700, 3.0, 25);
    topLight.position.set(0, 18, 0);
    scene.add(topLight);

    // è¾…åŠ©å…‰ï¼ˆç•¥å¸¦çº¢è‰²è°ƒï¼Œå¢å¼ºçº¢è‰²è£…é¥°ï¼‰
    const fillLight = new THREE.PointLight(0xffcccc, 1.2, 50);
    fillLight.position.set(-12, 8, 10);
    scene.add(fillLight);
}

function setupEventListeners() {
    // æŒ‰é’®æ§åˆ¶
    const foldedBtn = document.getElementById('folded-btn');
    const scatteredBtn = document.getElementById('scattered-btn');

    if (foldedBtn) {
        foldedBtn.onclick = () => {
            console.log('èšåˆæŒ‰é’®è¢«ç‚¹å‡»');
            changeState('folded');
        };
    } else {
        console.error('æœªæ‰¾åˆ°èšåˆæŒ‰é’®');
    }

    if (scatteredBtn) {
        scatteredBtn.onclick = () => {
            console.log('æ•£å¼€æŒ‰é’®è¢«ç‚¹å‡»');
            changeState('scattered');
        };
    } else {
        console.error('æœªæ‰¾åˆ°æ•£å¼€æŒ‰é’®');
    }

    // é¼ æ ‡ç§»åŠ¨äº¤äº’
    window.addEventListener('mousemove', onMouseMove, false);

    // çª—å£ç¼©æ”¾
    window.onresize = () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    };
}

function onMouseMove(event) {
    // å°†é¼ æ ‡ä½ç½®è½¬æ¢ä¸º3Dç©ºé—´åæ ‡
    const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
    const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

    // ç®€åŒ–ï¼šå°†é¼ æ ‡æŠ•å½±åˆ°ç›¸æœºå‰æ–¹å¹³é¢
    mouse3D.x = mouseX * 15;
    mouse3D.y = mouseY * 15;
    mouse3D.z = 0;
}

// ==================== å›¾ç‰‡åŠ è½½ ====================
function loadMessageImage() {
    const loader = new THREE.TextureLoader();
    loader.load(
        'message.svg',
        (texture) => {
            console.log('ç¥ç¦å›¾ç‰‡åŠ è½½æˆåŠŸ');
            createMessageImage(texture);
        },
        undefined,
        (error) => {
            console.error('ç¥ç¦å›¾ç‰‡åŠ è½½å¤±è´¥:', error);
            console.log('ç»§ç»­è¿è¡Œï¼Œä¸å½±å“ç²’å­æ•ˆæœ');
        }
    );
}

function createMessageImage(texture) {
    // åˆ›å»ºç¥ç¦å›¾ç‰‡å¹³é¢
    const geometry = new THREE.PlaneGeometry(8, 6);
    const material = new THREE.MeshStandardMaterial({
        map: texture,
        side: THREE.DoubleSide,
        metalness: 0.2,
        roughness: 0.4,
        emissive: 0xffd700,
        emissiveIntensity: 0.3,
        transparent: true,
        opacity: 0
    });

    messageImage = new THREE.Mesh(geometry, material);
    messageImage.position.set(0, 4, 0);  // åœ¨æ ‘çš„ä¸­å¿ƒä½ç½®
    messageImage.userData.targetOpacity = 0;
    scene.add(messageImage);
}

// ==================== ç²’å­ç³»ç»Ÿ ====================
function createParticles() {
    // ä½¿ç”¨ BufferGeometry åˆ›å»ºå¤§é‡ç²’å­ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    const colors = [];
    const sizes = [];
    const phases = [];  // å‘¼å¸é—ªçƒç›¸ä½

    for (let i = 0; i < CONFIG.particleCount; i++) {
        const ratio = i / CONFIG.particleCount;

        // è®¡ç®—åˆå§‹ä½ç½®ï¼ˆæ•£å¼€æ€ï¼‰
        const scatteredPos = getScatteredPosition();
        positions.push(scatteredPos.x, scatteredPos.y, scatteredPos.z);

        // æ ¹æ®é«˜åº¦åˆ†é…æ¢¦å¹»æ¸å˜è‰²
        let color;
        if (ratio > 0.7) {
            // ä¸Šå±‚ - å†°é›ªè“
            color = new THREE.Color(CONFIG.colors.iceBlue);
        } else if (ratio > 0.4) {
            // ä¸­å±‚ - æå…‰ç»¿
            color = new THREE.Color(CONFIG.colors.auroraGreen);
        } else {
            // ä¸‹å±‚ - ç¥ç€é‡‘
            color = new THREE.Color(CONFIG.colors.amber);
        }

        colors.push(color.r, color.g, color.b);

        // éšæœºç²’å­å¤§å°ï¼ˆç»†å°ç²’å­ï¼‰
        const size = 0.05 + Math.random() * 0.08;
        sizes.push(size);

        // éšæœºå‘¼å¸ç›¸ä½
        phases.push(Math.random() * Math.PI * 2);

        // å­˜å‚¨ç²’å­æ•°æ®
        particles.push({
            ratio: ratio,
            foldedPos: null,  // ç¨åè®¡ç®—
            scatteredPos: scatteredPos,
            originalPos: scatteredPos.clone(),
            phase: phases[i],
            size: size
        });
    }

    // è®¡ç®—æ‰€æœ‰ç²’å­çš„åˆæ‹¢æ€ä½ç½®
    particles.forEach((p, i) => {
        p.foldedPos = getFoldedPosition(p.ratio);
        // æ›´æ–°åˆå§‹ä½ç½®ä¸ºæ•£å¼€æ€
        positions[i * 3] = p.scatteredPos.x;
        positions[i * 3 + 1] = p.scatteredPos.y;
        positions[i * 3 + 2] = p.scatteredPos.z;
    });

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

    // ç²’å­æè´¨ - ä½¿ç”¨å åŠ å‘å…‰æ¨¡å¼
    const material = new THREE.PointsMaterial({
        size: 0.08,
        vertexColors: true,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,  // å åŠ å‘å…‰ï¼
        depthWrite: false,
        sizeAttenuation: true
    });

    const pointCloud = new THREE.Points(geometry, material);
    scene.add(pointCloud);

    // å­˜å‚¨å¼•ç”¨ç”¨äºæ›´æ–°
    pointCloud.userData.particles = particles;

    console.log('å·²åˆ›å»º ' + CONFIG.particleCount + ' ä¸ªæ¢¦å¹»ç²’å­');
    document.getElementById('gesture-status').innerText = 'ç‚¹å‡»æŒ‰é’®æ§åˆ¶åœ£è¯æ ‘';

    // åˆ›å»ºé¡¶éƒ¨äº”è§’æ˜Ÿ
    createStar();
}

function getScatteredPosition() {
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);
    const r = 15 + Math.random() * 15;
    return new THREE.Vector3(
        r * Math.sin(phi) * Math.cos(theta),
        r * Math.sin(phi) * Math.sin(theta),
        r * Math.cos(phi)
    );
}

function getFoldedPosition(ratio) {
    // åœ£è¯æ ‘èºæ—‹åœ†é”¥
    const treeHeight = 14;
    const treeBottom = -2;
    const numLayers = 9;

    if (ratio > 0.95) {
        // é¡¶éƒ¨å°–é¡¶
        const tipRatio = (ratio - 0.95) / 0.05;
        const tipHeight = treeBottom + treeHeight;
        const tipRadius = 0.2 * (1 - tipRatio);
        const tipAngle = Math.random() * Math.PI * 2;
        return new THREE.Vector3(
            Math.cos(tipAngle) * tipRadius,
            tipHeight - tipRatio * 0.5,
            Math.sin(tipAngle) * tipRadius
        );
    } else {
        // åˆ†å±‚ç»“æ„
        const treeRatio = ratio / 0.95;
        const layerIndex = Math.floor(treeRatio * numLayers);
        const layerProgress = layerIndex / numLayers;

        const layerY = treeBottom + (layerProgress * treeHeight);
        const yJitter = (Math.random() - 0.5) * 0.4;

        const baseRadius = 6.0 - layerProgress * 5.5;
        const radiusVariation = 1 + (Math.random() - 0.5) * 0.3;
        const particleRadius = baseRadius * radiusVariation;

        const angle = Math.random() * Math.PI * 2;
        const densityBias = Math.pow(Math.random(), 0.6);
        const r = particleRadius * densityBias;

        const droop = -0.15 * (r / baseRadius);

        return new THREE.Vector3(
            Math.cos(angle) * r,
            layerY + yJitter + droop,
            Math.sin(angle) * r
        );
    }
}

// åˆ›å»ºé¡¶éƒ¨äº”è§’æ˜Ÿ
function createStar() {
    // ä½¿ç”¨ç®€å•çš„æ˜Ÿæ˜Ÿå½¢çŠ¶
    const starGeometry = new THREE.SphereGeometry(0.4, 16, 16);
    const starMaterial = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.starGold,
        metalness: 0.9,
        roughness: 0.1,
        emissive: CONFIG.colors.starGold,
        emissiveIntensity: 2.5
    });

    star = new THREE.Mesh(starGeometry, starMaterial);
    star.position.set(0, 12, 0);  // æ ‘é¡¶ä½ç½®
    scene.add(star);
}

function setupParticlePositions(mesh, ratio) {
    // æ­¤å‡½æ•°å·²åºŸå¼ƒï¼Œä¿ç•™ä»¥é˜²å…¼å®¹

    // å®šä¹‰æ ‘çš„æ•´ä½“å‚æ•°
    const treeHeight = 14;      // æ€»é«˜åº¦
    const treeBottom = -2;      // åº•éƒ¨Yåæ ‡
    const numLayers = 9;        // æ ‘æå±‚æ•°

    // åˆ¤æ–­ç²’å­å±äºå“ªä¸€å±‚ï¼ˆé¡¶éƒ¨5%ä½œä¸ºæ˜Ÿæ˜Ÿå°–é¡¶ï¼‰
    let layerIndex, layerRatio;

    if (ratio > 0.95) {
        // æœ€é¡¶éƒ¨5%ï¼šå°–é¡¶æ˜Ÿæ˜ŸåŒºåŸŸ
        const tipRatio = (ratio - 0.95) / 0.05;
        const tipHeight = treeBottom + treeHeight;
        const tipRadius = 0.2 * (1 - tipRatio);
        const tipAngle = Math.random() * Math.PI * 2;

        mesh.userData.foldedPos = new THREE.Vector3(
            Math.cos(tipAngle) * tipRadius,
            tipHeight - tipRatio * 0.5,
            Math.sin(tipAngle) * tipRadius
        );
    } else {
        // 95%çš„ç²’å­ï¼šåˆ†å±‚æ ‘æç»“æ„
        const treeRatio = ratio / 0.95;
        layerIndex = Math.floor(treeRatio * numLayers);
        layerRatio = (treeRatio * numLayers) % 1;

        // æ¯å±‚çš„å‚æ•°ï¼ˆä»ä¸‹åˆ°ä¸Šï¼‰
        const layerProgress = layerIndex / numLayers;

        // å±‚çš„Yåæ ‡ï¼ˆæœ‰é—´éš”çš„å±‚æ¬¡æ„Ÿï¼‰
        const layerY = treeBottom + (layerProgress * treeHeight);
        const yJitter = (Math.random() - 0.5) * 0.4; // å±‚å†…é«˜åº¦æŠ–åŠ¨

        // å±‚çš„åŠå¾„ï¼ˆä¸‹å¤§ä¸Šå°ï¼Œå½¢æˆåœ†é”¥ï¼‰
        const baseRadius = 6.0 - layerProgress * 5.5; // ä»6é€’å‡åˆ°0.5
        const radiusVariation = 1 + (Math.random() - 0.5) * 0.3; // Â±15%æ³¢åŠ¨
        const particleRadius = baseRadius * radiusVariation;

        // å±‚å†…éšæœºè§’åº¦åˆ†å¸ƒ
        const angle = Math.random() * Math.PI * 2;

        // å¯†åº¦åˆ†å¸ƒï¼šå¤–å±‚åˆ°å†…å±‚çš„éšæœºåˆ†å¸ƒï¼ˆå¤§éƒ¨åˆ†åœ¨å¤–ä¾§ï¼‰
        const densityBias = Math.pow(Math.random(), 0.6); // åå‘å¤–ä¾§
        const r = particleRadius * densityBias;

        // æ ‘æå‘ä¸‹å€¾æ–œæ•ˆæœ
        const droop = -0.15 * (r / baseRadius); // å¤–ä¾§ç²’å­ç•¥å¾®ä¸‹å‚

        mesh.userData.foldedPos = new THREE.Vector3(
            Math.cos(angle) * r,
            layerY + yJitter + droop,
            Math.sin(angle) * r
        );
    }

    // ========== æ•£å¼€æ€ä½ç½®ï¼ˆéšæœºçƒå½¢åˆ†å¸ƒï¼‰==========
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);
    const r = 15 + Math.random() * 15;
    mesh.userData.scatteredPos = new THREE.Vector3(
        r * Math.sin(phi) * Math.cos(theta),
        r * Math.sin(phi) * Math.sin(theta),
        r * Math.cos(phi)
    );

    // åˆå§‹ä½ç½®ï¼ˆæ•£å¼€çŠ¶æ€ï¼‰
    mesh.position.copy(mesh.userData.scatteredPos);
    mesh.userData.originalScale = mesh.scale.clone();
}

// ==================== çŠ¶æ€ç®¡ç† ====================
function changeState(newState) {
    if (currentState === newState) return;

    currentState = newState;

    const statusText = {
        'folded': 'ğŸ„ åœ£è¯æ ‘å½¢æ€ - ç¥ç¦æ˜¾ç°',
        'scattered': 'âœ¨ ç²’å­æ•£å¼€'
    };

    document.getElementById('gesture-status').innerText = statusText[newState] || '';

    // æ›´æ–°å›¾ç‰‡é€æ˜åº¦
    if (messageImage) {
        messageImage.userData.targetOpacity = (newState === 'folded') ? 1 : 0;
    }
}

function updateParticles() {
    const pointCloud = scene.children.find(obj => obj.type === 'Points');
    if (!pointCloud) return;

    const positions = pointCloud.geometry.attributes.position.array;
    const sizes = pointCloud.geometry.attributes.size.array;
    const time = Date.now() * 0.001;  // æ—¶é—´ï¼ˆç§’ï¼‰

    particles.forEach((particle, i) => {
        // ç¡®å®šç›®æ ‡ä½ç½®
        const targetPos = currentState === 'folded' ?
            particle.foldedPos : particle.scatteredPos;

        // å½“å‰ä½ç½®
        let currentX = positions[i * 3];
        let currentY = positions[i * 3 + 1];
        let currentZ = positions[i * 3 + 2];

        // å¹³æ»‘è¿‡æ¸¡åˆ°ç›®æ ‡ä½ç½®
        currentX += (targetPos.x - currentX) * CONFIG.lerpSpeed;
        currentY += (targetPos.y - currentY) * CONFIG.lerpSpeed;
        currentZ += (targetPos.z - currentZ) * CONFIG.lerpSpeed;

        // ç²’å­é£˜åŠ¨æ•ˆæœï¼ˆè½»å¾®æ­£å¼¦æ³¢ï¼‰
        const driftX = Math.sin(time + particle.phase) * 0.1;
        const driftY = Math.cos(time * 0.7 + particle.phase) * 0.1;
        const driftZ = Math.sin(time * 0.5 + particle.phase) * 0.08;

        currentX += driftX;
        currentY += driftY;
        currentZ += driftZ;

        // é¼ æ ‡äº¤äº’ï¼ˆæ’æ–¥/è·Ÿéšï¼‰
        const dx = currentX - mouse3D.x;
        const dy = currentY - mouse3D.y;
        const dz = currentZ - mouse3D.z;
        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

        if (distance < CONFIG.mouseInfluenceRadius) {
            // æ’æ–¥åŠ›ï¼ˆè¿‘è·ç¦»ï¼‰
            const force = (1 - distance / CONFIG.mouseInfluenceRadius) * CONFIG.mouseForce;
            currentX += (dx / distance) * force;
            currentY += (dy / distance) * force;
            currentZ += (dz / distance) * force;
        }

        // æ›´æ–°ä½ç½®
        positions[i * 3] = currentX;
        positions[i * 3 + 1] = currentY;
        positions[i * 3 + 2] = currentZ;

        // å‘¼å¸é—ªçƒæ•ˆæœï¼ˆå¤§å°å˜åŒ–ï¼‰
        const breathe = 0.8 + Math.sin(time * 2 + particle.phase) * 0.3;
        sizes[i] = particle.size * breathe;
    });

    // æ ‡è®°å‡ ä½•ä½“éœ€è¦æ›´æ–°
    pointCloud.geometry.attributes.position.needsUpdate = true;
    pointCloud.geometry.attributes.size.needsUpdate = true;

    // æ˜Ÿæ˜Ÿæ—‹è½¬
    if (star) {
        star.rotation.y += 0.02;
        star.rotation.z = Math.sin(time) * 0.1;  // è½»å¾®æ‘‡æ‘†
    }

    // æ›´æ–°å›¾ç‰‡é€æ˜åº¦
    if (messageImage) {
        const currentOpacity = messageImage.material.opacity;
        const targetOpacity = messageImage.userData.targetOpacity;
        messageImage.material.opacity += (targetOpacity - currentOpacity) * 0.05;
    }
}

// ==================== åŠ¨ç”»å¾ªç¯ ====================
function animate() {
    requestAnimationFrame(animate);

    if (particles.length > 0) {
        updateParticles();

        // åœºæ™¯å¾®æ—‹è½¬ï¼ˆä»…åœ¨åˆæ‹¢æ€ï¼‰
        if (currentState === 'folded') {
            scene.rotation.y += 0.002;
        }
    }

    // æ¸²æŸ“åœºæ™¯
    renderer.render(scene, camera);
}

// ==================== å¯åŠ¨ ====================
window.onload = init;
</script>
</body>
</html>
