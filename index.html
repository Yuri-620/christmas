<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>æ‰‹åŠ¿æ§åˆ¶åœ£è¯æ ‘ - Gesture Christmas Tree</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background: #000000;  /* çº¯é»‘èƒŒæ™¯ */
            overflow: hidden;
            color: #ffd700;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #status-panel {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
        }

        #status-panel h1 {
            font-size: 2.5em;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(212, 175, 55, 0.5);
            margin-bottom: 10px;
        }

        #gesture-status {
            font-size: 1.2em;
            color: #d4af37;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.6);
            padding: 10px 25px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 20px;
            display: inline-block;
        }


        #video-preview {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border: 2px solid #d4af37;
            border-radius: 10px;
            transform: scaleX(-1);
            display: none;
        }

        #instructions {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #d4af37;
            font-size: 0.9em;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px 30px;
            border-radius: 15px;
        }

        #instructions div {
            margin: 5px 0;
        }
    </style>
</head>
<body>

<div id="canvas-container"></div>

<div id="ui-overlay">
    <div id="status-panel">
        <h1>ğŸ„ æ‰‹åŠ¿åœ£è¯æ ‘</h1>
        <div id="gesture-status">æ­£åœ¨åŠ è½½...</div>
    </div>

    <div id="instructions">
        <div>âœŠ æ¡æ‹³ - èšåˆæˆæ ‘ï¼ˆæ˜¾ç¤ºç¥ç¦ï¼‰</div>
        <div>âœ‹ å¼ å¼€ - ç²’å­æ•£å¼€</div>
        <div>ğŸ”„ ç§»åŠ¨æ‰‹ - æ—‹è½¬è§†è§’</div>
    </div>
</div>

<video id="video-preview" autoplay playsinline></video>

<!-- Three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<!-- MediaPipe Hands -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

<script>
// ==================== å…¨å±€å˜é‡ ====================
let scene, camera, renderer;
let particles = [];
let messageImage = null;  // ç¥ç¦å›¾ç‰‡
let currentState = 'scattered'; // 'folded', 'scattered'ï¼ˆåˆå§‹ä¸ºæ•£å¼€çŠ¶æ€ï¼‰
let handPosition = { x: 0, y: 0 };
let lastHandRotation = 0;

const CONFIG = {
    particleCount: 800,
    colors: {
        gold1: 0xffd700,      // äº®é‡‘è‰²
        gold2: 0xffaa00,      // æ©™é‡‘è‰²
        gold3: 0xffe066,      // æµ…é‡‘è‰²
        star: 0xffffdd        // æ˜Ÿæ˜Ÿç™½é‡‘è‰²
    },
    lerpSpeed: 0.08,
    cameraDistance: 28
};

// ==================== åˆå§‹åŒ– ====================
function init() {
    if (typeof THREE === 'undefined') {
        document.getElementById('gesture-status').innerText = 'é”™è¯¯ï¼šæ— æ³•åŠ è½½ Three.js';
        return;
    }

    // åœºæ™¯
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);  // çº¯é»‘èƒŒæ™¯
    // ç§»é™¤é›¾æ•ˆï¼Œä¿æŒæ¸…æ™°

    // ç›¸æœº
    camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );
    camera.position.set(0, 5, CONFIG.cameraDistance); // æé«˜ç›¸æœºä½ç½®ï¼Œä¿¯è§†è§’åº¦
    camera.lookAt(0, 4, 0);  // çœ‹å‘æ ‘çš„ä¸­ä¸Šéƒ¨

    // æ¸²æŸ“å™¨
    renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.5;  // æé«˜æ›å…‰ï¼Œå¢å¼ºå‘å…‰æ•ˆæœ
    renderer.shadowMap.enabled = false;   // å…³é—­é˜´å½±ï¼Œä¸éœ€è¦
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // å…‰ç…§ç³»ç»Ÿ
    setupLights();

    // äº‹ä»¶ç›‘å¬
    setupEventListeners();

    // åŠ è½½ç¥ç¦å›¾ç‰‡
    loadMessageImage();

    // åˆ›å»ºç²’å­ç³»ç»Ÿ
    createParticles();

    // åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«
    initMediaPipe();

    animate();
}

function setupLights() {
    // å¾®å¼±ç¯å¢ƒå…‰ï¼ˆä¸»è¦é ç²’å­è‡ªå‘å…‰ï¼‰
    const ambientLight = new THREE.AmbientLight(0x444444, 0.1);
    scene.add(ambientLight);

    // ä¸»å…‰æºï¼ˆå¼ºé‡‘è‰²ï¼‰
    const mainLight = new THREE.PointLight(0xffd700, 2.5, 60);
    mainLight.position.set(0, 15, 15);
    scene.add(mainLight);

    // é¡¶éƒ¨èšå…‰ç¯ï¼ˆç…§äº®æ˜Ÿæ˜Ÿï¼‰
    const topLight = new THREE.PointLight(0xffffee, 3.0, 25);
    topLight.position.set(0, 18, 0);
    scene.add(topLight);

    // è¾…åŠ©é‡‘å…‰
    const fillLight = new THREE.PointLight(0xffaa00, 1.5, 50);
    fillLight.position.set(-12, 8, 10);
    scene.add(fillLight);
}

function setupEventListeners() {
    // çª—å£ç¼©æ”¾
    window.onresize = () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    };
}

// ==================== å›¾ç‰‡åŠ è½½ ====================
function loadMessageImage() {
    const loader = new THREE.TextureLoader();
    loader.load(
        'message.svg',
        (texture) => {
            console.log('ç¥ç¦å›¾ç‰‡åŠ è½½æˆåŠŸ');
            createMessageImage(texture);
        },
        undefined,
        (error) => {
            console.error('ç¥ç¦å›¾ç‰‡åŠ è½½å¤±è´¥:', error);
            console.log('ç»§ç»­è¿è¡Œï¼Œä¸å½±å“ç²’å­æ•ˆæœ');
        }
    );
}

function createMessageImage(texture) {
    // åˆ›å»ºç¥ç¦å›¾ç‰‡å¹³é¢
    const geometry = new THREE.PlaneGeometry(8, 6);
    const material = new THREE.MeshStandardMaterial({
        map: texture,
        side: THREE.DoubleSide,
        metalness: 0.2,
        roughness: 0.4,
        emissive: 0xffd700,
        emissiveIntensity: 0.3,
        transparent: true,
        opacity: 0
    });

    messageImage = new THREE.Mesh(geometry, material);
    messageImage.position.set(0, 4, 0);  // åœ¨æ ‘çš„ä¸­å¿ƒä½ç½®
    messageImage.userData.targetOpacity = 0;
    scene.add(messageImage);
}

// ==================== ç²’å­ç³»ç»Ÿ ====================
function createParticles() {
    // åˆ›å»ºå‡ ä½•ä½“ç²’å­ - å…¨éƒ¨é‡‘è‰²ç³»
    for (let i = 0; i < CONFIG.particleCount; i++) {
        const ratio = i / CONFIG.particleCount;
        const type = i % 3;
        let geometry, material;

        // æ ¹æ®ä½ç½®é€‰æ‹©é‡‘è‰²ï¼ˆé¡¶éƒ¨æ›´äº®ï¼‰
        let goldColor, emissiveIntensity;
        if (ratio > 0.95) {
            // é¡¶éƒ¨æ˜Ÿæ˜ŸåŒºåŸŸ - æœ€äº®
            goldColor = CONFIG.colors.star;
            emissiveIntensity = 2.0;
        } else if (ratio > 0.7) {
            // ä¸Šå±‚ - äº®é‡‘è‰²
            goldColor = CONFIG.colors.gold1;
            emissiveIntensity = 1.2;
        } else if (ratio > 0.4) {
            // ä¸­å±‚ - æ ‡å‡†é‡‘è‰²
            goldColor = CONFIG.colors.gold2;
            emissiveIntensity = 1.0;
        } else {
            // ä¸‹å±‚ - æ©™é‡‘è‰²
            goldColor = CONFIG.colors.gold3;
            emissiveIntensity = 0.9;
        }

        if (type === 0) {
            // çƒä½“ï¼ˆ70%ï¼‰
            geometry = new THREE.SphereGeometry(0.1, 8, 8);
            material = new THREE.MeshStandardMaterial({
                color: goldColor,
                metalness: 0.7,
                roughness: 0.15,
                emissive: goldColor,
                emissiveIntensity: emissiveIntensity
            });
        } else if (type === 1) {
            // æ­£æ–¹ä½“ï¼ˆ15%ï¼‰
            geometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
            material = new THREE.MeshStandardMaterial({
                color: goldColor,
                metalness: 0.8,
                roughness: 0.1,
                emissive: goldColor,
                emissiveIntensity: emissiveIntensity * 1.2  // æ–¹å—æ›´äº®
            });
        } else {
            // å°å…‰ç‚¹ï¼ˆ15%ï¼‰- æ›´å°çš„çƒä½“
            geometry = new THREE.SphereGeometry(0.06, 6, 6);
            material = new THREE.MeshStandardMaterial({
                color: goldColor,
                metalness: 0.9,
                roughness: 0.05,
                emissive: goldColor,
                emissiveIntensity: emissiveIntensity * 1.5  // å…‰ç‚¹æœ€äº®
            });
        }

        const mesh = new THREE.Mesh(geometry, material);
        mesh.userData.type = type === 0 ? 'sphere' : (type === 1 ? 'cube' : 'light');
        setupParticlePositions(mesh, ratio);
        scene.add(mesh);
        particles.push(mesh);
    }

    console.log('å·²åˆ›å»º ' + CONFIG.particleCount + ' ä¸ªç²’å­');
    document.getElementById('gesture-status').innerText = 'âœ‹ å¼ å¼€æ‰‹æ•£å¼€ / âœŠ æ¡æ‹³èšåˆ';
}

function setupParticlePositions(mesh, ratio) {
    // ========== åˆæ‹¢æ€ï¼šå†™å®çš„åˆ†å±‚åœ£è¯æ ‘ ==========

    // å®šä¹‰æ ‘çš„æ•´ä½“å‚æ•°
    const treeHeight = 14;      // æ€»é«˜åº¦
    const treeBottom = -2;      // åº•éƒ¨Yåæ ‡
    const numLayers = 9;        // æ ‘æå±‚æ•°

    // åˆ¤æ–­ç²’å­å±äºå“ªä¸€å±‚ï¼ˆé¡¶éƒ¨5%ä½œä¸ºæ˜Ÿæ˜Ÿå°–é¡¶ï¼‰
    let layerIndex, layerRatio;

    if (ratio > 0.95) {
        // æœ€é¡¶éƒ¨5%ï¼šå°–é¡¶æ˜Ÿæ˜ŸåŒºåŸŸ
        const tipRatio = (ratio - 0.95) / 0.05;
        const tipHeight = treeBottom + treeHeight;
        const tipRadius = 0.2 * (1 - tipRatio);
        const tipAngle = Math.random() * Math.PI * 2;

        mesh.userData.foldedPos = new THREE.Vector3(
            Math.cos(tipAngle) * tipRadius,
            tipHeight - tipRatio * 0.5,
            Math.sin(tipAngle) * tipRadius
        );
    } else {
        // 95%çš„ç²’å­ï¼šåˆ†å±‚æ ‘æç»“æ„
        const treeRatio = ratio / 0.95;
        layerIndex = Math.floor(treeRatio * numLayers);
        layerRatio = (treeRatio * numLayers) % 1;

        // æ¯å±‚çš„å‚æ•°ï¼ˆä»ä¸‹åˆ°ä¸Šï¼‰
        const layerProgress = layerIndex / numLayers;

        // å±‚çš„Yåæ ‡ï¼ˆæœ‰é—´éš”çš„å±‚æ¬¡æ„Ÿï¼‰
        const layerY = treeBottom + (layerProgress * treeHeight);
        const yJitter = (Math.random() - 0.5) * 0.4; // å±‚å†…é«˜åº¦æŠ–åŠ¨

        // å±‚çš„åŠå¾„ï¼ˆä¸‹å¤§ä¸Šå°ï¼Œå½¢æˆåœ†é”¥ï¼‰
        const baseRadius = 6.0 - layerProgress * 5.5; // ä»6é€’å‡åˆ°0.5
        const radiusVariation = 1 + (Math.random() - 0.5) * 0.3; // Â±15%æ³¢åŠ¨
        const particleRadius = baseRadius * radiusVariation;

        // å±‚å†…éšæœºè§’åº¦åˆ†å¸ƒ
        const angle = Math.random() * Math.PI * 2;

        // å¯†åº¦åˆ†å¸ƒï¼šå¤–å±‚åˆ°å†…å±‚çš„éšæœºåˆ†å¸ƒï¼ˆå¤§éƒ¨åˆ†åœ¨å¤–ä¾§ï¼‰
        const densityBias = Math.pow(Math.random(), 0.6); // åå‘å¤–ä¾§
        const r = particleRadius * densityBias;

        // æ ‘æå‘ä¸‹å€¾æ–œæ•ˆæœ
        const droop = -0.15 * (r / baseRadius); // å¤–ä¾§ç²’å­ç•¥å¾®ä¸‹å‚

        mesh.userData.foldedPos = new THREE.Vector3(
            Math.cos(angle) * r,
            layerY + yJitter + droop,
            Math.sin(angle) * r
        );
    }

    // ========== æ•£å¼€æ€ä½ç½®ï¼ˆéšæœºçƒå½¢åˆ†å¸ƒï¼‰==========
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);
    const r = 15 + Math.random() * 15;
    mesh.userData.scatteredPos = new THREE.Vector3(
        r * Math.sin(phi) * Math.cos(theta),
        r * Math.sin(phi) * Math.sin(theta),
        r * Math.cos(phi)
    );

    // åˆå§‹ä½ç½®ï¼ˆæ•£å¼€çŠ¶æ€ï¼‰
    mesh.position.copy(mesh.userData.scatteredPos);
    mesh.userData.originalScale = mesh.scale.clone();
}

// ==================== çŠ¶æ€ç®¡ç† ====================
function changeState(newState) {
    if (currentState === newState) return;

    currentState = newState;

    const statusText = {
        'folded': 'ğŸ„ åœ£è¯æ ‘å½¢æ€ - ç¥ç¦æ˜¾ç°',
        'scattered': 'âœ¨ ç²’å­æ•£å¼€'
    };

    document.getElementById('gesture-status').innerText = statusText[newState] || '';

    // æ›´æ–°å›¾ç‰‡é€æ˜åº¦
    if (messageImage) {
        messageImage.userData.targetOpacity = (newState === 'folded') ? 1 : 0;
    }
}

function updateParticles() {
    particles.forEach((particle, i) => {
        let targetPos, targetScale;

        if (currentState === 'folded') {
            targetPos = particle.userData.foldedPos;
            targetScale = particle.userData.originalScale;
        } else {
            targetPos = particle.userData.scatteredPos;
            targetScale = particle.userData.originalScale;
        }

        // å¹³æ»‘è¿‡æ¸¡
        particle.position.lerp(targetPos, CONFIG.lerpSpeed);
        particle.scale.lerp(targetScale, CONFIG.lerpSpeed);

        // è‡ªè½¬
        particle.rotation.y += 0.01;
        if (particle.userData.type === 'cube') {
            particle.rotation.x += 0.015;
            particle.rotation.z += 0.01;
        }
    });

    // æ›´æ–°å›¾ç‰‡é€æ˜åº¦
    if (messageImage) {
        const currentOpacity = messageImage.material.opacity;
        const targetOpacity = messageImage.userData.targetOpacity;
        messageImage.material.opacity += (targetOpacity - currentOpacity) * 0.05;
    }
}

// ==================== MediaPipe Hands ====================
let hands, cameraInstance;
let lastGestureTime = 0;
const gestureThrottle = 100; // 100ms èŠ‚æµ

function initMediaPipe() {
    if (typeof Hands === 'undefined') {
        console.error('æ— æ³•åŠ è½½æ‰‹åŠ¿è¯†åˆ«åº“');
        document.getElementById('gesture-status').innerText = 'æ— æ³•åŠ è½½æ‰‹åŠ¿è¯†åˆ«åº“ï¼Œä½†ç²’å­æ•ˆæœå¯ç”¨';
        return;
    }

    hands = new Hands({
        locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }
    });

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });

    hands.onResults(onHandsResults);

    // å¯åŠ¨æ‘„åƒå¤´
    const videoElement = document.getElementById('video-preview');
    navigator.mediaDevices.getUserMedia({
        video: { width: 640, height: 480 }
    }).then((stream) => {
        videoElement.srcObject = stream;
        videoElement.style.display = 'block';

        cameraInstance = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 640,
            height: 480
        });
        cameraInstance.start();

        console.log('æ‘„åƒå¤´å·²å¯åŠ¨ï¼Œæ‰‹åŠ¿è¯†åˆ«å°±ç»ª');
    }).catch((err) => {
        console.error('æ‘„åƒå¤´è®¿é—®å¤±è´¥:', err);
        document.getElementById('gesture-status').innerText = 'æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œä½†ç²’å­æ•ˆæœå¯ç”¨';
    });
}

function onHandsResults(results) {
    if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
        return;
    }

    const now = Date.now();
    if (now - lastGestureTime < gestureThrottle) return;

    const landmarks = results.multiHandLandmarks[0];
    detectGestures(landmarks);

    lastGestureTime = now;
}

function detectGestures(landmarks) {
    // å…³é”®ç‚¹
    const wrist = landmarks[0];
    const thumbTip = landmarks[4];
    const indexTip = landmarks[8];
    const middleTip = landmarks[12];
    const ringTip = landmarks[16];
    const pinkyTip = landmarks[20];

    const indexBase = landmarks[5];
    const middleBase = landmarks[9];

    // æ›´æ–°æ‰‹éƒ¨ä½ç½®ï¼ˆç”¨äºæ—‹è½¬ï¼‰
    handPosition.x = wrist.x * 2 - 1;
    handPosition.y = -(wrist.y * 2 - 1);

    // 1. æ¡æ‹³æ£€æµ‹ï¼ˆæ‰€æœ‰æ‰‹æŒ‡é è¿‘æ‰‹æŒï¼‰
    const fingersClosed =
        distance(thumbTip, wrist) < 0.2 &&
        distance(indexTip, wrist) < 0.2 &&
        distance(middleTip, wrist) < 0.2 &&
        distance(ringTip, wrist) < 0.2 &&
        distance(pinkyTip, wrist) < 0.2;

    if (fingersClosed) {
        changeState('folded');
        return;
    }

    // 2. å¼ å¼€æ‰‹æ£€æµ‹ï¼ˆæ‰€æœ‰æ‰‹æŒ‡ä¼¸å±•ï¼‰
    const fingersOpen =
        distance(thumbTip, wrist) > 0.3 &&
        distance(indexTip, wrist) > 0.35 &&
        distance(middleTip, wrist) > 0.35 &&
        distance(ringTip, wrist) > 0.3 &&
        distance(pinkyTip, wrist) > 0.28;

    if (fingersOpen) {
        changeState('scattered');

        // æ‰‹ç§»åŠ¨æ—‹è½¬ç›¸æœº
        const rotation = Math.atan2(handPosition.y, handPosition.x);
        const deltaRotation = rotation - lastHandRotation;

        if (Math.abs(deltaRotation) > 0.05 && Math.abs(deltaRotation) < 1) {
            const radius = CONFIG.cameraDistance;
            const currentAngle = Math.atan2(camera.position.z, camera.position.x);
            const newAngle = currentAngle + deltaRotation * 0.5;

            camera.position.x = radius * Math.cos(newAngle);
            camera.position.z = radius * Math.sin(newAngle);
            camera.lookAt(0, 4, 0);  // çœ‹å‘æ ‘çš„ä¸­å¿ƒ
        }

        lastHandRotation = rotation;
        return;
    }
}

function distance(p1, p2) {
    return Math.sqrt(
        Math.pow(p1.x - p2.x, 2) +
        Math.pow(p1.y - p2.y, 2) +
        Math.pow(p1.z - p2.z, 2)
    );
}

// ==================== åŠ¨ç”»å¾ªç¯ ====================
function animate() {
    requestAnimationFrame(animate);

    if (particles.length > 0) {
        updateParticles();

        // åœºæ™¯å¾®æ—‹è½¬ï¼ˆä»…åœ¨åˆæ‹¢æ€ï¼‰
        if (currentState === 'folded') {
            scene.rotation.y += 0.002;
        }
    }

    // æ¸²æŸ“åœºæ™¯
    renderer.render(scene, camera);
}

// ==================== å¯åŠ¨ ====================
window.onload = init;
</script>
</body>
</html>
