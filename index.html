<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>æ‰‹åŠ¿æ§åˆ¶åœ£è¯æ ‘ - Gesture Christmas Tree</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background: #000000;  /* çº¯é»‘èƒŒæ™¯ */
            overflow: hidden;
            color: #ffd700;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #status-panel {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
        }

        #status-panel h1 {
            font-size: 2.5em;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(212, 175, 55, 0.5);
            margin-bottom: 10px;
        }

        #gesture-status {
            font-size: 1.2em;
            color: #d4af37;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.6);
            padding: 10px 25px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 20px;
            display: inline-block;
        }

        #upload-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.8);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid #d4af37;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.3);
        }

        #upload-panel.hidden { display: none; }

        #upload-button {
            padding: 15px 40px;
            font-size: 1.2em;
            background: linear-gradient(135deg, #d4af37 0%, #ffd700 100%);
            color: #0a0e0a;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 5px 20px rgba(212, 175, 55, 0.4);
            transition: all 0.3s;
            margin-top: 20px;
        }

        #upload-button:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 30px rgba(212, 175, 55, 0.6);
        }

        #file-input { display: none; }

        #video-preview {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border: 2px solid #d4af37;
            border-radius: 10px;
            transform: scaleX(-1);
            display: none;
        }

        #instructions {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #d4af37;
            font-size: 0.9em;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px 30px;
            border-radius: 15px;
        }

        #instructions div {
            margin: 5px 0;
        }
    </style>
</head>
<body>

<div id="canvas-container"></div>

<div id="ui-overlay">
    <div id="status-panel">
        <h1>ğŸ„ æ‰‹åŠ¿åœ£è¯æ ‘</h1>
        <div id="gesture-status">ç‚¹å‡»"è·³è¿‡"ç›´æ¥ä½“éªŒï¼Œæˆ–ä¸Šä¼ ç…§ç‰‡</div>
    </div>

    <div id="upload-panel">
        <h2>ä¸Šä¼ æ‚¨çš„åœ£è¯ç…§ç‰‡</h2>
        <p style="color: #ccc; margin: 15px 0;">é€‰æ‹©å¤šå¼ ç…§ç‰‡ç»„æˆåœ£è¯æ ‘ï¼ˆå¯é€‰ï¼‰</p>
        <input type="file" id="file-input" accept="image/*" multiple>
        <button id="upload-button">é€‰æ‹©ç…§ç‰‡</button>
        <button id="skip-button" style="background: linear-gradient(135deg, #666 0%, #888 100%); margin-left: 10px;">è·³è¿‡ï¼Œç›´æ¥ä½“éªŒ</button>
    </div>

    <div id="instructions">
        <div>âœŠ æ¡æ‹³ - èšåˆæˆæ ‘</div>
        <div>âœ‹ å¼ å¼€ - ç²’å­æ•£å¼€</div>
        <div>ğŸ”„ ç§»åŠ¨æ‰‹ - æ—‹è½¬è§†è§’</div>
        <div>ğŸ¤ æåˆ - æ”¾å¤§ç…§ç‰‡</div>
    </div>
</div>

<video id="video-preview" autoplay playsinline></video>

<!-- Three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<!-- Post-processing -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>

<!-- MediaPipe Hands -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

<script>
// ==================== å…¨å±€å˜é‡ ====================
let scene, camera, renderer, composer;
let particles = [];
let photoTextures = [];
let currentState = 'folded'; // 'folded', 'scattered', 'photoZoom'
let targetPhotoIndex = -1;
let handPosition = { x: 0, y: 0 };
let lastHandRotation = 0;

const CONFIG = {
    particleCount: 800,
    colors: {
        gold1: 0xffd700,      // äº®é‡‘è‰²
        gold2: 0xffaa00,      // æ©™é‡‘è‰²
        gold3: 0xffe066,      // æµ…é‡‘è‰²
        star: 0xffffdd        // æ˜Ÿæ˜Ÿç™½é‡‘è‰²
    },
    lerpSpeed: 0.08,
    cameraDistance: 28
};

// ==================== åˆå§‹åŒ– ====================
function init() {
    if (typeof THREE === 'undefined') {
        document.getElementById('gesture-status').innerText = 'é”™è¯¯ï¼šæ— æ³•åŠ è½½ Three.js';
        return;
    }

    // åœºæ™¯
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);  // çº¯é»‘èƒŒæ™¯
    // ç§»é™¤é›¾æ•ˆï¼Œä¿æŒæ¸…æ™°

    // ç›¸æœº
    camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );
    camera.position.set(0, 5, CONFIG.cameraDistance); // æé«˜ç›¸æœºä½ç½®ï¼Œä¿¯è§†è§’åº¦
    camera.lookAt(0, 4, 0);  // çœ‹å‘æ ‘çš„ä¸­ä¸Šéƒ¨

    // æ¸²æŸ“å™¨
    renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.5;  // æé«˜æ›å…‰ï¼Œå¢å¼ºå‘å…‰æ•ˆæœ
    renderer.shadowMap.enabled = false;   // å…³é—­é˜´å½±ï¼Œä¸éœ€è¦
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // å…‰ç…§ç³»ç»Ÿ
    setupLights();

    // åæœŸå¤„ç†ï¼ˆBloomæ•ˆæœï¼‰
    setupPostProcessing();

    // äº‹ä»¶ç›‘å¬
    setupEventListeners();

    animate();
}

function setupLights() {
    // å¾®å¼±ç¯å¢ƒå…‰ï¼ˆä¸»è¦é ç²’å­è‡ªå‘å…‰ï¼‰
    const ambientLight = new THREE.AmbientLight(0x444444, 0.1);
    scene.add(ambientLight);

    // ä¸»å…‰æºï¼ˆå¼ºé‡‘è‰²ï¼‰
    const mainLight = new THREE.PointLight(0xffd700, 2.5, 60);
    mainLight.position.set(0, 15, 15);
    scene.add(mainLight);

    // é¡¶éƒ¨èšå…‰ç¯ï¼ˆç…§äº®æ˜Ÿæ˜Ÿï¼‰
    const topLight = new THREE.PointLight(0xffffee, 3.0, 25);
    topLight.position.set(0, 18, 0);
    scene.add(topLight);

    // è¾…åŠ©é‡‘å…‰
    const fillLight = new THREE.PointLight(0xffaa00, 1.5, 50);
    fillLight.position.set(-12, 8, 10);
    scene.add(fillLight);
}

function setupPostProcessing() {
    // æ£€æŸ¥åæœŸå¤„ç†åº“æ˜¯å¦åŠ è½½
    if (typeof THREE.EffectComposer === 'undefined') {
        console.warn('EffectComposer not loaded, skipping bloom');
        return;
    }

    // åˆ›å»º EffectComposer
    composer = new THREE.EffectComposer(renderer);

    // æ¸²æŸ“é€šé“
    const renderPass = new THREE.RenderPass(scene, camera);
    composer.addPass(renderPass);

    // Bloom é€šé“ï¼ˆå¼ºè¾‰å…‰æ•ˆæœï¼‰
    const bloomPass = new THREE.UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        2.0,    // å¼ºåº¦ï¼š2.0ï¼ˆå¼ºçƒˆè¾‰å…‰ï¼‰
        1.0,    // åŠå¾„ï¼š1.0
        0.1     // é˜ˆå€¼ï¼š0.1ï¼ˆä½é˜ˆå€¼ï¼Œè®©æ‰€æœ‰ç²’å­å‘å…‰ï¼‰
    );
    composer.addPass(bloomPass);

    console.log('Bloom post-processing enabled');
}

function setupEventListeners() {
    // ä¸Šä¼ æŒ‰é’®
    document.getElementById('upload-button').onclick = () => {
        document.getElementById('file-input').click();
    };

    // è·³è¿‡æŒ‰é’®
    document.getElementById('skip-button').onclick = () => {
        document.getElementById('upload-panel').classList.add('hidden');
        photoTextures = [];  // ç©ºç…§ç‰‡æ•°ç»„
        createParticles();
        initMediaPipe();
    };

    // æ–‡ä»¶ä¸Šä¼ 
    document.getElementById('file-input').onchange = handleFileUpload;

    // çª—å£ç¼©æ”¾
    window.onresize = () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        if (composer) {
            composer.setSize(window.innerWidth, window.innerHeight);
        }
    };
}

// ==================== ç…§ç‰‡ç³»ç»Ÿ ====================
function handleFileUpload(event) {
    const files = event.target.files;
    if (files.length === 0) return;

    document.getElementById('gesture-status').innerText = 'åŠ è½½ç…§ç‰‡ä¸­...';

    let loadedCount = 0;
    let targetCount = Math.min(files.length, 20);
    photoTextures = [];

    for (let i = 0; i < targetCount; i++) {
        const file = files[i];
        const reader = new FileReader();

        reader.onload = (e) => {
            const loader = new THREE.TextureLoader();
            loader.load(
                e.target.result,
                (texture) => {
                    // æˆåŠŸåŠ è½½
                    photoTextures.push(texture);
                    loadedCount++;
                    document.getElementById('gesture-status').innerText =
                        `å·²åŠ è½½ ${loadedCount}/${targetCount} å¼ ç…§ç‰‡`;

                    if (loadedCount === targetCount) {
                        document.getElementById('upload-panel').classList.add('hidden');
                        createParticles();
                        initMediaPipe();
                    }
                },
                undefined,
                (error) => {
                    // åŠ è½½å¤±è´¥
                    console.error('ç…§ç‰‡åŠ è½½å¤±è´¥:', error);
                    loadedCount++;
                    if (loadedCount === targetCount) {
                        document.getElementById('upload-panel').classList.add('hidden');
                        createParticles();
                        initMediaPipe();
                    }
                }
            );
        };

        reader.onerror = () => {
            console.error('æ–‡ä»¶è¯»å–å¤±è´¥');
            loadedCount++;
            if (loadedCount === targetCount) {
                document.getElementById('upload-panel').classList.add('hidden');
                createParticles();
                initMediaPipe();
            }
        };

        reader.readAsDataURL(file);
    }
}

// ==================== ç²’å­ç³»ç»Ÿ ====================
function createParticles() {
    const photoCount = photoTextures.length;
    const regularCount = CONFIG.particleCount - photoCount;

    // åˆ›å»ºç…§ç‰‡ç²’å­ï¼ˆå¯é€‰ï¼šéšè—ç…§ç‰‡çªå‡ºé‡‘è‰²æ•ˆæœï¼‰
    photoTextures.forEach((texture, i) => {
        const geometry = new THREE.PlaneGeometry(1.0, 1.0);
        const material = new THREE.MeshStandardMaterial({
            map: texture,
            side: THREE.DoubleSide,
            metalness: 0.3,
            roughness: 0.3,
            emissive: 0xffd700,      // é‡‘è‰²å‘å…‰è¾¹ç¼˜
            emissiveIntensity: 0.5,  // ä¸­ç­‰å‘å…‰
            opacity: 0.8,            // ç•¥é€æ˜ï¼Œèå…¥é‡‘è‰²æ°›å›´
            transparent: true
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.userData.type = 'photo';
        mesh.userData.index = i;
        setupParticlePositions(mesh, i / CONFIG.particleCount);
        scene.add(mesh);
        particles.push(mesh);
    });

    // åˆ›å»ºå‡ ä½•ä½“ç²’å­ - å…¨éƒ¨é‡‘è‰²ç³»
    for (let i = photoCount; i < CONFIG.particleCount; i++) {
        const ratio = i / CONFIG.particleCount;
        const type = i % 3;
        let geometry, material;

        // æ ¹æ®ä½ç½®é€‰æ‹©é‡‘è‰²ï¼ˆé¡¶éƒ¨æ›´äº®ï¼‰
        let goldColor, emissiveIntensity;
        if (ratio > 0.95) {
            // é¡¶éƒ¨æ˜Ÿæ˜ŸåŒºåŸŸ - æœ€äº®
            goldColor = CONFIG.colors.star;
            emissiveIntensity = 2.0;
        } else if (ratio > 0.7) {
            // ä¸Šå±‚ - äº®é‡‘è‰²
            goldColor = CONFIG.colors.gold1;
            emissiveIntensity = 1.2;
        } else if (ratio > 0.4) {
            // ä¸­å±‚ - æ ‡å‡†é‡‘è‰²
            goldColor = CONFIG.colors.gold2;
            emissiveIntensity = 1.0;
        } else {
            // ä¸‹å±‚ - æ©™é‡‘è‰²
            goldColor = CONFIG.colors.gold3;
            emissiveIntensity = 0.9;
        }

        if (type === 0) {
            // çƒä½“ï¼ˆ70%ï¼‰
            geometry = new THREE.SphereGeometry(0.1, 8, 8);
            material = new THREE.MeshStandardMaterial({
                color: goldColor,
                metalness: 0.7,
                roughness: 0.15,
                emissive: goldColor,
                emissiveIntensity: emissiveIntensity
            });
        } else if (type === 1) {
            // æ­£æ–¹ä½“ï¼ˆ15%ï¼‰
            geometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
            material = new THREE.MeshStandardMaterial({
                color: goldColor,
                metalness: 0.8,
                roughness: 0.1,
                emissive: goldColor,
                emissiveIntensity: emissiveIntensity * 1.2  // æ–¹å—æ›´äº®
            });
        } else {
            // å°å…‰ç‚¹ï¼ˆ15%ï¼‰- æ›´å°çš„çƒä½“
            geometry = new THREE.SphereGeometry(0.06, 6, 6);
            material = new THREE.MeshStandardMaterial({
                color: goldColor,
                metalness: 0.9,
                roughness: 0.05,
                emissive: goldColor,
                emissiveIntensity: emissiveIntensity * 1.5  // å…‰ç‚¹æœ€äº®
            });
        }

        const mesh = new THREE.Mesh(geometry, material);
        mesh.userData.type = type === 0 ? 'sphere' : (type === 1 ? 'cube' : 'light');
        setupParticlePositions(mesh, ratio);
        scene.add(mesh);
        particles.push(mesh);
    }

    document.getElementById('gesture-status').innerText = 'å·²åŠ è½½ ' + CONFIG.particleCount + ' ä¸ªå…ƒç´ ';
}

function setupParticlePositions(mesh, ratio) {
    // ========== åˆæ‹¢æ€ï¼šå†™å®çš„åˆ†å±‚åœ£è¯æ ‘ ==========

    // å®šä¹‰æ ‘çš„æ•´ä½“å‚æ•°
    const treeHeight = 14;      // æ€»é«˜åº¦
    const treeBottom = -2;      // åº•éƒ¨Yåæ ‡
    const numLayers = 9;        // æ ‘æå±‚æ•°

    // åˆ¤æ–­ç²’å­å±äºå“ªä¸€å±‚ï¼ˆé¡¶éƒ¨5%ä½œä¸ºæ˜Ÿæ˜Ÿå°–é¡¶ï¼‰
    let layerIndex, layerRatio;

    if (ratio > 0.95) {
        // æœ€é¡¶éƒ¨5%ï¼šå°–é¡¶æ˜Ÿæ˜ŸåŒºåŸŸ
        const tipRatio = (ratio - 0.95) / 0.05;
        const tipHeight = treeBottom + treeHeight;
        const tipRadius = 0.2 * (1 - tipRatio);
        const tipAngle = Math.random() * Math.PI * 2;

        mesh.userData.foldedPos = new THREE.Vector3(
            Math.cos(tipAngle) * tipRadius,
            tipHeight - tipRatio * 0.5,
            Math.sin(tipAngle) * tipRadius
        );
    } else {
        // 95%çš„ç²’å­ï¼šåˆ†å±‚æ ‘æç»“æ„
        const treeRatio = ratio / 0.95;
        layerIndex = Math.floor(treeRatio * numLayers);
        layerRatio = (treeRatio * numLayers) % 1;

        // æ¯å±‚çš„å‚æ•°ï¼ˆä»ä¸‹åˆ°ä¸Šï¼‰
        const layerProgress = layerIndex / numLayers;

        // å±‚çš„Yåæ ‡ï¼ˆæœ‰é—´éš”çš„å±‚æ¬¡æ„Ÿï¼‰
        const layerY = treeBottom + (layerProgress * treeHeight);
        const yJitter = (Math.random() - 0.5) * 0.4; // å±‚å†…é«˜åº¦æŠ–åŠ¨

        // å±‚çš„åŠå¾„ï¼ˆä¸‹å¤§ä¸Šå°ï¼Œå½¢æˆåœ†é”¥ï¼‰
        const baseRadius = 6.0 - layerProgress * 5.5; // ä»6é€’å‡åˆ°0.5
        const radiusVariation = 1 + (Math.random() - 0.5) * 0.3; // Â±15%æ³¢åŠ¨
        const particleRadius = baseRadius * radiusVariation;

        // å±‚å†…éšæœºè§’åº¦åˆ†å¸ƒ
        const angle = Math.random() * Math.PI * 2;

        // å¯†åº¦åˆ†å¸ƒï¼šå¤–å±‚åˆ°å†…å±‚çš„éšæœºåˆ†å¸ƒï¼ˆå¤§éƒ¨åˆ†åœ¨å¤–ä¾§ï¼‰
        const densityBias = Math.pow(Math.random(), 0.6); // åå‘å¤–ä¾§
        const r = particleRadius * densityBias;

        // æ ‘æå‘ä¸‹å€¾æ–œæ•ˆæœ
        const droop = -0.15 * (r / baseRadius); // å¤–ä¾§ç²’å­ç•¥å¾®ä¸‹å‚

        mesh.userData.foldedPos = new THREE.Vector3(
            Math.cos(angle) * r,
            layerY + yJitter + droop,
            Math.sin(angle) * r
        );
    }

    // ========== æ•£å¼€æ€ä½ç½®ï¼ˆéšæœºçƒå½¢åˆ†å¸ƒï¼‰==========
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);
    const r = 15 + Math.random() * 15;
    mesh.userData.scatteredPos = new THREE.Vector3(
        r * Math.sin(phi) * Math.cos(theta),
        r * Math.sin(phi) * Math.sin(theta),
        r * Math.cos(phi)
    );

    // åˆå§‹ä½ç½®
    mesh.position.copy(mesh.userData.foldedPos);
    mesh.userData.originalScale = mesh.scale.clone();
}

// ==================== çŠ¶æ€ç®¡ç† ====================
function changeState(newState, photoIndex = -1) {
    if (currentState === newState && photoIndex === targetPhotoIndex) return;

    currentState = newState;
    targetPhotoIndex = photoIndex;

    const statusText = {
        'folded': 'ğŸ„ åœ£è¯æ ‘å½¢æ€',
        'scattered': 'âœ¨ ç²’å­æ•£å¼€',
        'photoZoom': 'ğŸ“¸ ç…§ç‰‡ç‰¹å†™'
    };

    document.getElementById('gesture-status').innerText = statusText[newState] || '';
}

function updateParticles() {
    particles.forEach((particle, i) => {
        let targetPos, targetScale;

        if (currentState === 'folded') {
            targetPos = particle.userData.foldedPos;
            targetScale = particle.userData.originalScale;
        } else if (currentState === 'scattered') {
            targetPos = particle.userData.scatteredPos;
            targetScale = particle.userData.originalScale;
        } else if (currentState === 'photoZoom') {
            if (particle.userData.type === 'photo' && particle.userData.index === targetPhotoIndex) {
                targetPos = new THREE.Vector3(0, 0, 5);
                targetScale = particle.userData.originalScale.clone().multiplyScalar(5);
            } else {
                targetPos = particle.userData.scatteredPos.clone().multiplyScalar(1.5);
                targetScale = particle.userData.originalScale.clone().multiplyScalar(0.3);
            }
        }

        // å¹³æ»‘è¿‡æ¸¡
        particle.position.lerp(targetPos, CONFIG.lerpSpeed);
        particle.scale.lerp(targetScale, CONFIG.lerpSpeed);

        // è‡ªè½¬
        particle.rotation.y += 0.01;
        if (particle.userData.type === 'cube') {
            particle.rotation.x += 0.015;
            particle.rotation.z += 0.01;
        }
    });
}

// ==================== MediaPipe Hands ====================
let hands, cameraInstance;
let lastGestureTime = 0;
const gestureThrottle = 100; // 100ms èŠ‚æµ

function initMediaPipe() {
    if (typeof Hands === 'undefined') {
        document.getElementById('gesture-status').innerText = 'æ— æ³•åŠ è½½æ‰‹åŠ¿è¯†åˆ«åº“';
        return;
    }

    hands = new Hands({
        locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }
    });

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });

    hands.onResults(onHandsResults);

    // å¯åŠ¨æ‘„åƒå¤´
    const videoElement = document.getElementById('video-preview');
    navigator.mediaDevices.getUserMedia({
        video: { width: 640, height: 480 }
    }).then((stream) => {
        videoElement.srcObject = stream;
        videoElement.style.display = 'block';

        cameraInstance = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 640,
            height: 480
        });
        cameraInstance.start();

        document.getElementById('gesture-status').innerText = 'ğŸ‘‹ æ˜¾ç¤ºæ‚¨çš„æ‰‹åŠ¿';
    }).catch((err) => {
        document.getElementById('gesture-status').innerText = 'æ— æ³•è®¿é—®æ‘„åƒå¤´';
        console.error(err);
    });
}

function onHandsResults(results) {
    if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
        return;
    }

    const now = Date.now();
    if (now - lastGestureTime < gestureThrottle) return;

    const landmarks = results.multiHandLandmarks[0];
    detectGestures(landmarks);

    lastGestureTime = now;
}

function detectGestures(landmarks) {
    // å…³é”®ç‚¹
    const wrist = landmarks[0];
    const thumbTip = landmarks[4];
    const indexTip = landmarks[8];
    const middleTip = landmarks[12];
    const ringTip = landmarks[16];
    const pinkyTip = landmarks[20];

    const indexBase = landmarks[5];
    const middleBase = landmarks[9];

    // æ›´æ–°æ‰‹éƒ¨ä½ç½®ï¼ˆç”¨äºæ—‹è½¬ï¼‰
    handPosition.x = wrist.x * 2 - 1;
    handPosition.y = -(wrist.y * 2 - 1);

    // 1. æ¡æ‹³æ£€æµ‹ï¼ˆæ‰€æœ‰æ‰‹æŒ‡é è¿‘æ‰‹æŒï¼‰
    const fingersClosed =
        distance(thumbTip, wrist) < 0.2 &&
        distance(indexTip, wrist) < 0.2 &&
        distance(middleTip, wrist) < 0.2 &&
        distance(ringTip, wrist) < 0.2 &&
        distance(pinkyTip, wrist) < 0.2;

    if (fingersClosed) {
        changeState('folded');
        return;
    }

    // 2. å¼ å¼€æ‰‹æ£€æµ‹ï¼ˆæ‰€æœ‰æ‰‹æŒ‡ä¼¸å±•ï¼‰
    const fingersOpen =
        distance(thumbTip, wrist) > 0.3 &&
        distance(indexTip, wrist) > 0.35 &&
        distance(middleTip, wrist) > 0.35 &&
        distance(ringTip, wrist) > 0.3 &&
        distance(pinkyTip, wrist) > 0.28;

    if (fingersOpen) {
        changeState('scattered');

        // æ‰‹ç§»åŠ¨æ—‹è½¬ç›¸æœº
        const rotation = Math.atan2(handPosition.y, handPosition.x);
        const deltaRotation = rotation - lastHandRotation;

        if (Math.abs(deltaRotation) > 0.05 && Math.abs(deltaRotation) < 1) {
            const radius = CONFIG.cameraDistance;
            const currentAngle = Math.atan2(camera.position.z, camera.position.x);
            const newAngle = currentAngle + deltaRotation * 0.5;

            camera.position.x = radius * Math.cos(newAngle);
            camera.position.z = radius * Math.sin(newAngle);
            camera.lookAt(0, 4, 0);  // çœ‹å‘æ ‘çš„ä¸­å¿ƒ
        }

        lastHandRotation = rotation;
        return;
    }

    // 3. æåˆæ£€æµ‹ï¼ˆæ‹‡æŒ‡å’Œé£ŸæŒ‡æ¥è¿‘ï¼‰
    const pinchDistance = distance(thumbTip, indexTip);
    if (pinchDistance < 0.05) {
        // æ‰¾åˆ°æœ€è¿‘çš„ç…§ç‰‡
        const photoParticles = particles.filter(p => p.userData.type === 'photo');
        if (photoParticles.length > 0) {
            // ç®€åŒ–ï¼šé€‰æ‹©ç¬¬ä¸€å¼ ç…§ç‰‡
            const closestIndex = photoParticles[0].userData.index;
            changeState('photoZoom', closestIndex);
        }
        return;
    }
}

function distance(p1, p2) {
    return Math.sqrt(
        Math.pow(p1.x - p2.x, 2) +
        Math.pow(p1.y - p2.y, 2) +
        Math.pow(p1.z - p2.z, 2)
    );
}

// ==================== åŠ¨ç”»å¾ªç¯ ====================
function animate() {
    requestAnimationFrame(animate);

    if (particles.length > 0) {
        updateParticles();

        // åœºæ™¯å¾®æ—‹è½¬ï¼ˆä»…åœ¨åˆæ‹¢æ€ï¼‰
        if (currentState === 'folded') {
            scene.rotation.y += 0.002;
        }
    }

    // ä½¿ç”¨ composer æ¸²æŸ“ï¼ˆå¸¦ Bloom æ•ˆæœï¼‰
    if (composer) {
        composer.render();
    } else {
        renderer.render(scene, camera);
    }
}

// ==================== å¯åŠ¨ ====================
window.onload = init;
</script>
</body>
</html>
